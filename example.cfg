[algorithm]
# Number of iterations to perform.
# Recommend 5+, monitor mean velocity variance in log for guidance.
niter    = 9

# Number of random realizations per iteration.
# At least 50, 100 is safer? They get faster over time.
nreal    = 100

# Number of Voronoi cells per realization.
# Keep an eye on avg cell width and rays per cell to decide on something reasonable.
# Only cells with >= min_rays_per_cell will be used.
# Bigger is not always better!
nvoronoi = 600

# How many raypaths have to travel through a cell for it to be counted.
# Will depend on your experiment, but recommend at least 3.
min_rays_per_cell = 5

# Number of Voronoi cells distributed using k-medians clustering.
# This is in PERCENT of NVORONOI (default 5%)
# Increases increases meshing time by a factor of ~1.5x
kvoronoi = 5

# Number of raypath points used in k-medians clustering. This is in PERCENT OF ARRIVALS (default 15%)
# This controls how well the raypath distribution is sampled to find the cell positions
# Increases increases meshing time linearly ~ 1x
# Note this is only in use for non-adaptive meshing (adaptive_data_weight = 0)
k_medians_percent = 15

# Horizontal-to-vertical ratio for stretching Voronoi cells.
# A ratio of max distance / max raypath depth seems sensible (e.g., for shallow events 150/25 = 6?).
hvr = 6

# Scale factor alpha in Pareto's distribution from which cell depths are sampled.
# Higher value yields greater concentration of cells near the surface.
# Set this to 0 if you want to draw from a uniform distribution.
# Sensible range is 0-3 with 3 being "very" concentrated to the surface.
paretos_alpha = 1

# Should Voronoi cells be generated adaptively and to what degree?
# Not tested especially well, plus a k_medians scheme is probably better?
adaptive_data_weight=0.3

# Number of events & arrivals to sample per realization.
# Confirm good numbers with average rays per cell. 
# Ballpark: events 40% of total and arrivals 20% of total? (per phase!)
# Note that many arrivals may be QC'd out via min residual AND tukey fencing, 
#   so best to juice narrival a bit higher than your desired amount
nevent = 3000
narrival = 20000

# alternatively, can express via % of total available (per run!)
#   if set, over-rides nevent and narrival
#     recommended!
nevent_percent = 50
# note that narrivals will be a ratio of the remaining arrivals pre-decimated
#  so from your total you divide /2 for P/S then multiply by nevent_percent
narrival_percent = 40

# Threshold for # arrivals for each event.
#    Events with fewer than min_arrival arrivals are removed at the start.
# If using a "cleaned" catalog, may need to lower this
min_narrival = 13

# Remove arrivals by distance window (km)
# Does not apply to events with an depth greater than cutoff_depth (km, default 50)
#    this allows, for example, deep events to pass regardless of distance
cutoff_depth=50
# Recommend min_dist at 2x the model resolution and max_dist to be about 150 km or less
#    to avoid refracted waves and reflections
min_dist=7
max_dist=150

# Remove arrivals & events if residuals (seconds) too large.
# These are hardline values so don't set TOO tightly.. things may improve!
#    Remember, Tukey fencing will remove relative arrival residuals per realization
max_arrival_residual = 0.9
max_event_residual = 1.2

# Remove events that have migrated beyond these limits. Only checks first 3 iterations.
#   lat/lon in degrees, depth in km, time in seconds
# May be good to restart with these relocated events pre-removed from your starting catalog
max_dlat = 0.15
max_dlon = 0.15
max_ddepth = 25
max_dtime = 2.0

# If set, assign hard boundaries that events cannot migrate past
#    to avoid "runaway relocations" in poorly resolved areas
# min_depth = 0
max_depth = 15

# Set which phases to run, and in what order
#   Default is P and then S, but world's your oyster
phase_order=P,S

# Multiplicative factor for arrivals outlier removal using Tukey fences
# Applied _per realization_
#   Smaller values = stricter QC
#   ex IQR = 1.349 x std. 
#      so, IQR 0.741 = 1.0 std, IQR 1.0 = 2.0 std, IQR 1.5 = 2.7 std, IQR 3.0 = 4.7 std
outlier_removal_factor = 1.0

# The following parameters (atol, btol, maxiter, conlim, and damp)
#    are passed through directly to scipy.sparse.linalg.lsmr().
# Atol is roughly the precision of your velocity model (default 1e-4, OK to be a little less)
atol = 1e-4

# Btol is roughly the precision of your time residuals/expected velocity model
# default is 0.05 seconds... is your mean pick error that good?
btol = 0.05

# You shouldn't see anything close to these ideally, but the solver is fast
maxiter = 1000
conlim = 1000

# If damp is < 0, will compute a reasonable 3D estimate per iteration (recommended!) 
# Otherwise you can eyeball this and set a consistent factor for all iterations
damp = -1


[model]

# IF SET, filter stations (only! events will be subsequently filtered via max_dist)
# format is: minlat,minlon,maxlat,maxlon (degrees)
#map_filter = -31,115,-27,120

# Velocity model loadable using pykonal.fields.load
initial_pwave_path = ./swaus.P.h5
initial_swave_path = ./swaus.S.h5

# Perform a "checkerboard" resolution test at the end?
perform_res_test = True
# Checkerboard horizontal size (km), vertical depth (km), and strength (decimal ratio)
res_test_size_mag = 75,25,0.08

# If set, specify the vertical depths (km) the checkerboard will flip polarity
# res_test_layers = 6,18,50

# If pyvorotomo is ran with the -t flag, then ONLY do the checkerboard test assuming
# the latest model and catalogs found in the rerun_restest directory
rerun_restest = /home/pickle/pyvorotomo/output_SWAN06


[relocate]
# Set the "method" parameter here to "linear" for linearized relocation
# or "DE" for differential evolution relocation.
# STRONGLY Recommend using DE unless you have a specific reason not to
method = DE


[de_relocation]
# This section is only needed if the "method" parameter of the "relocate" section is set to "DE".
# These set the absolute maximum Differential Evolution search range for a new event.
# Keeping these values smaller increases both speed and stability, but will require more iterations 
depth_min = -1.5
dlat = 0.07
dlon = 0.07
ddepth = 3
dtime = 0.25


[linearized_relocation]
# This section is only needed if the "method" parameter of the "relocate" section is set to "linear".
atol = 1e-4
btol = 1e-2
conlim = 100
damp = 0.1
maxiter = 100
