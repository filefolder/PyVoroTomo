[algorithm]
# Number of iterations to perform.
# Recommend 5+, monitor mean velocity variance in log for guidance.
niter    = 2

# Number of random realizations per iteration.
# At least 50, 100 is safer? They get faster over time.
nreal    = 50

# Number of Voronoi cells per realization.
# Keep an eye on avg cell width and rays per cell to decide on something reasonable.
# Only cells with >= min_rays_per_cell will be used.
# Bigger is not always better!
nvoronoi = 990

# How many raypaths have to travel through a cell for it to be counted.
# Will depend on your experiment, but recommend at least 3.
min_rays_per_cell = 5

# Number of Voronoi cells distributed using k-medians clustering.
# This is in PERCENT of NVORONOI (default 5%)
# Increases increases meshing time by a factor of ~1.5x
kvoronoi = 5

# Number of raypath points used in k-medians clustering. This is in PERCENT OF ARRIVALS (default 15%)
# This controls how well the raypath distribution is sampled to find the cell positions
# Increases increases meshing time linearly ~ 1x
# Note this is only in use for non-adaptive meshing (adaptive_data_weight = 0)
k_medians_percent = 10

# Horizontal-to-vertical ratio for stretching Voronoi cells.
# A ratio of max distance / max raypath depth seems sensible (e.g., for shallow events 150/25 = 6?).
hvr = 4

# Scale factor alpha in Pareto's distribution from which cell depths are sampled.
# Higher value yields greater concentration of cells near the surface.
# Set this to 0 if you want to draw from a uniform distribution.
# Sensible range is 0-3 with 3 being "very" concentrated to the surface.
paretos_alpha = 1

# Should Voronoi cells be generated adaptively and to what degree?
# Not tested especially well, plus a k_medians scheme is probably better?
adaptive_data_weight=0.25

# Number of events & arrivals to sample per realization.
# Confirm good numbers with average rays per cell. 
# Ballpark: events 40% of total and arrivals 20% of total? (per phase!)
# Note that many arrivals may be QC'd out via min residual AND tukey fencing, 
#   so best to juice narrival a bit higher than your desired amount
nevent = 500
narrival = 5000

# alternatively, can express via % of total available (per run!)
#   if set, over-rides nevent and narrival
#     recommended!
nevent_percent = 50
# note that narrivals will be a ratio of the remaining arrivals pre-decimated
#  so from your total you divide /2 for P/S then multiply by nevent_percent
narrival_percent = 40

# Threshold for # arrivals for each event.
#    Events with fewer than min_arrival arrivals are removed at the start.
# If using a "cleaned" catalog, may need to lower this considerably
min_narrival = 10

# Remove arrivals by distance window (km)
# Does not apply to events with an depth greater than cutoff_depth (km, default 50)
#    which allows, for example, deep events to pass regardless of distance
# Recommend min_dist at 2x the model resolution and max_dist to be about 150 km or less
#    to avoid refracted waves and reflections
cutoff_depth=50
min_dist=7
max_dist=150

# Remove arrivals & events if residuals (seconds) too large.
# These are hardline values so don't set TOO tightly..
#    Tukey fencing will remove relative arrival residuals per realization
max_arrival_residual = 1.0
max_event_residual = 1.5


# Remove events that have migrated beyond these limits. Only checks first 3 iterations.
# lat/lon in degrees, depth in km, time in seconds
# May be good to remove these relocated events from your starting catalog
max_dlat = 0.10
max_dlon = 0.10
max_ddepth = 7
max_dtime = 1.0

# Assign hard boundaries that events cannot migrate past
#    to avoid "runaway relocations" in poorly resolved areas
# if unset, not used
#min_depth = 0
#max_depth = 15

# Set which phases and what order to run. Default is P and then S, but you could do whatever.
# While parameter testing may be good to just run P.
# NOTE!!! There aren't any S arrivals in the example dataset
#phase_order=P,S
phase_order=P

# Multiplicative factor for arrivals outlier removal using Tukey fences
# Applied _per realization_
#   Smaller values = stricter QC
#   ex IQR = 1.349 x std. 
#      so, IQR 0.741 = 1.0 std, IQR 1.0 = 2.0 std, IQR 1.5 = 2.7 std, IQR 3.0 = 4.7 std
outlier_removal_factor = 1.0

# The following parameters (atol, btol, maxiter, conlim, and damp)
#    are passed through directly to scipy.sparse.linalg.lsmr().
# Atol is roughly the precision of your velocity model (default 1e-4, OK to be a little less)
atol = 1e-4

# Btol is roughly the precision of your time residuals/expected velocity model
# default is 0.05 seconds... is your mean pick error that good?
btol = 0.05

# You shouldn't see anything close to these ideally, but the solver is fast
maxiter = 1000
conlim = 1000

# If damp is < 0, will compute a reasonable 3D estimate per iteration (recommended!) 
# Otherwise you can eyeball this and set a consistent factor for all iterations
damp = -1



[model]

# IF SET, filter stations (only! events will be subsequently filtered via max_dist) to expedite model calibration
# format is: minlat,minlon,maxlat,maxlon (degrees)
#map_filter = -31,115,-27,120

# Velocity model loadable using pykonal.fields.load
initial_pwave_path = /full/path/to/test_data/socal/initial_pwave_model.h5
initial_swave_path = /full/path/to/test_data/socal/initial_swave_model.h5


# Perform a "checkerboard" resolution test at the end?
perform_res_test = True
# Checkerboard horizontal size (km), vertical depth (km), and strength (decimal ratio)
res_test_size_mag = 75,0.08
# Depths (km) where checkerboard will flip polarity (default is 10,25,50,70,120,170,230)
res_test_layers = 6,18,50

# If pyvorotomo is ran with the -t flag, then ONLY do the checkerboard test assuming
# the latest model and catalogs found in the rerun_restest directory
rerun_restest = /path/to/output_previous


[relocate]
# Set the "method" parameter here to "linear" for linearized relocation
# or "DE" for differential evolution relocation.
# Recommend using DE unless you have a specific reason not to
method = DE



[de_relocation]
# This section is only needed if the "method" parameter of the "relocate" section is set to "DE".
# These set the absolute maximum Differential Evolution search range for a new event.
# Keeping these values smaller increases both speed and stability, but will require more iterations 
depth_min = -1
dlat = 0.1
dlon = 0.1
ddepth = 2
dtime = 0.5



[linearized_relocation]
# This section is only needed if the "method" parameter of the "relocate" section is set to "linear".
atol = 1e-4
btol = 1e-2
conlim = 100
damp = 0.1
maxiter = 100

