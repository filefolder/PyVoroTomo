[model]

initial_pwave_path = ./synthetic_pwave_model.h5
initial_swave_path = ./synthetic_swave_model.h5
events_path = ./synthetic_events.h5
stations_path = ./synthetic_stations.h5


perform_res_test = True

res_test_size_mag = 50,0.05
res_test_layers = 12,24,60


# If pyvorotomo is ran with the -t flag, then ONLY do the checkerboard test assuming
# the latest model and catalogs found in the rerun_restest directory
# rerun_restest = /path/to/nada


[relocate]
# Set the "method" parameter here to "linear" for linearized relocation
# or "DE" for differential evolution relocation.
# Recommend using DE unless you have a specific reason not to
method = DE


[algorithm]
# Number of iterations to perform.
# Recommend 5+, monitor mean velocity variance in log for guidance.
niter    = 1

# Number of random realizations per iteration.
# At least 50, 100 is safer? They get faster over time.
nreal    = 100

# Number of Voronoi cells per realization.
# Keep an eye on avg cell width and rays per cell to decide on something reasonable.
# Only cells with >= min_rays_per_cell will be used.
# Bigger is not always better!
nvoronoi = 800

# How many raypaths have to travel through a cell for it to be counted.
# Will depend on your experiment, but recommend at least 3.
min_rays_per_cell = 5

# Number of Voronoi cells distributed using k-medians clustering.
# This is in PERCENT of NVORONOI (default 5%)
# Increases increases meshing time by a factor of ~1.5x
kvoronoi = 5

# Number of raypath points used in k-medians clustering. This is in PERCENT OF ARRIVALS (default 15%)
# This controls how well the raypath distribution is sampled to find the cell positions
# Increases increases meshing time linearly ~ 1x
# Note this is only in use for non-adaptive meshing (adaptive_data_weight = 0)
k_medians_percent = 5

# Horizontal-to-vertical ratio for stretching Voronoi cells.
# A ratio of max distance / max raypath depth seems sensible (e.g., for shallow events 150/25 = 6?).
# Also a good means to increase vertical resolution.
hvr = 3

# Scale factor alpha in Pareto's distribution from which cell depths are sampled.
# Higher value yields greater concentration of cells near the surface.
# Set this to 0 if you want to draw from a uniform distribution.
# Roughly scales linear, meaning a value of 3 will have about 3x more cells at the surface than bottom
paretos_alpha = 3

# Should Voronoi cells be generated adaptively and to what degree?
# This controls how far (%) cells will be adjusted based on raypath density and velocity gradients
# STRONGLY recommended! (Default is 0.5, disabled/purely random if set to 0)
adaptive_data_weight = 0.9

# What should the adaptive algorithm prioritize? This sets the relative weight between
#   raypath density and HORIZONTAL velocity model gradients. Values > 0.5 will place more adaptive
#   cells in areas of higher raypath density, < 0.5 prefer higher velocity gradients.
# Default is 0.5, an even mix. Only applies if adaptive_data_weight > 0.
density_to_gradient_weight = 0.1


# Number of events & arrivals to sample per realization.
# Confirm good numbers with average rays per cell. 
# Ballpark: events 40% of total and arrivals 20% of total? (per phase!)
# Note that many arrivals may be QC'd out via min residual AND tukey fencing, 
#   so best to juice narrival a bit higher than your desired amount
nevent = 160
narrival = 2500

# Alternatively, can express via % of total available (per run!).
# If set, over-rides nevent and narrival
# Recommended!
nevent_percent = 33
narrival_percent = 15

# Threshold for # arrivals for each event.
#    Events with fewer than min_arrival arrivals are removed at the start.
# If using a "cleaned" catalog, may need to lower this considerably
min_narrival = 6

# Remove arrivals by distance window (km)
# Does not apply to events with an depth greater than cutoff_depth (km, default 50)
#    which allows, for example, deep events to pass regardless of distance
# Recommend min_dist at 2x the model resolution and max_dist to be about 150 km or less
#    to avoid refracted waves and reflections
cutoff_depth=25
min_dist=0
max_dist=150

# Remove arrivals & events if residuals (seconds) too large.
# These are hardline values so don't set TOO tightly..
#    Tukey fencing will remove relative arrival residuals per realization
max_arrival_residual = 1
max_event_residual = 1


# Remove events that have migrated beyond these limits. Only checks first 3 iterations.
# lat/lon in degrees, depth in km, time in seconds
# May be good to remove these relocated events from your starting catalog
max_dlat = 1
max_dlon = 1
max_ddepth = 6
max_dtime = 2.0

# Assign hard boundaries that events cannot migrate past
#    to avoid "runaway relocations" in poorly resolved areas
# if unset, not used
#min_depth = 0
max_depth = 30

# Set which phases and what order to run. Default is P and then S, but you could do whatever.
# While parameter testing may be good to just run P.
phase_order=P,S

# Multiplicative factor for arrivals outlier removal using Tukey fences
# Ran per realization
# Smaller values = stricter QC
# ex IQR = 1.349 x std. so, IQR 0.741 = 1.0 std, IQR 1.0 = 2.0 std, IQR 1.5 = 2.7 std, IQR 3.0 = 4.7 std
outlier_removal_factor = 9

# The following parameters (atol, btol, maxiter, conlim, and damp)
#    are passed through directly to scipy.sparse.linalg.lsmr().
# Atol is roughly the precision of your velocity model (default 1e-4, OK to be a little less)
atol = 1e-4
btol = 0.03
maxiter = 1000
conlim = 1000
damp = -1



[de_relocation]
# keep very close for synthetic data since it's... already pretty close to perfect 
depth_min = 0
dlat = 0.03
dlon = 0.03
ddepth = 1
dtime = 0.05
